<App Name="Playstation 2" Icon="FOLDER" Category="5" Type="SUBMENU" Description="$`${this.Value.Items.length} ${XMBLANG.TITLES[UserConfig.Language]}`">
  <Options HideEmpty="true">
    <![CDATA[
			const NeutrinoCFG = CfgMan.Get("neutrino.cfg");

			function SaveLastPlayed() {
				NeutrinoCFG["last"] = DashUI.SelectedItem.Name;
				CfgMan.Set("neutrino.cfg", NeutrinoCFG);
				setHistoryEntry(DashUI.SelectedItem.GameID.toUpperCase());
			}

      function getGameID(obj) {
        if (obj.Name in NeutrinoCFG) {
					obj.GameID = NeutrinoCFG[obj.Name];
        }
        else {
					const gameID = getISOgameID(`${obj.Data.path}${obj.Data.fname}`, obj.Data.size);
					obj.GameID = gameID.success ? gameID.code : "";
          if (obj.GameID !== "") {
						NeutrinoCFG[obj.Name] = obj.GameID;
						CfgMan.Push("neutrino.cfg", NeutrinoCFG);
          }
        }

				obj.Description = obj.GameID + " \u{B7} " + obj.Data.dev.toUpperCase();
				obj.Data.id = obj.GameID;

				const ico = (obj.GameID !== "") ? findICO(obj.GameID) : "";
				if (ico !== "") { obj.CustomIcon = ico; }
				const bgFile = (obj.GameID !== "") ? findBG(obj.GameID) : "";
				if (bgFile !== "") { obj.CustomBG = bgFile; }
				const pic2 = (obj.GameID !== "") ? findArt(obj.GameID, "pic2.png") : "";
				if (pic2 !== "") { obj.PIC2 = pic2; }
      }

			function ScanGames(path, device, media) {
				const items = [];
				let gameDir = System.listDir(path);
				for (let j = 0; j < gameDir.length; j++) {
					if (gameDir[j].dir || (getFileExtension(gameDir[j].name).toLowerCase() !== "iso")) { continue; }

					items.push({
						Name: getGameName(gameDir[j].name),
						Type: "ELF",
						Data: { path: path, fname: gameDir[j].name, size: gameDir[j].size, fsize: formatFileSize(gameDir[j].size), dev: device, mt: media }
					});

          Object.defineProperty(items[items.length - 1], "Icon", {
						get() {
              getGameID(this);
              delete this.Icon;
              this.Icon = "DISC_PS2";
              return this.Icon;
            },
						enumerable: true,
            configurable: true
					});

					Object.defineProperty(items[items.length - 1], "Value", {
						get() {	return { Path: `${PATHS.Neutrino}neutrino.elf`, Args: getISOgameArgs(this.Data), Code: SaveLastPlayed }; },
						enumerable: true
					});
				}
				return items;
			}
			const devices = System.devices();
			const bsd = [];

			if (devices.some(dev => dev.name === "mass")) { bsd.push({ root: "mass", count: 10, device: "usb"  }); }
			if (devices.some(dev => dev.name === "hdd"))  { bsd.push({ root: "hdd",  count: 1,  device: "ata"  }); }
			if (devices.some(dev => dev.name === "mmce")) { bsd.push({ root: "mmce", count: 2,  device: "mmce" }); }

			let gameList = [];
			for (let i = 0; i < bsd.length; i++) {
				const b = bsd[i];
				for (let j = 0; j < b.count; j++) {
					const path = `${b.root}${j.toString()}:`;
					let dev = b.device;
					if (b.root === "mass") {
						const bdmInfo = System.getBDMInfo(path);
						if (!bdmInfo) { break; }
						switch (bdmInfo.name) {
							case "ata":
							case "usb": dev = bdmInfo.name; break;
							case "sdc": dev = "mx4sio"; 	break;
							case "sd" : dev = "ilink"; 		break;
							case "udp": dev = "udpbd"; 		break;
						}
						console.log(`BDM device ${bdmInfo.index} type: ${dev}`);
					}
					else if (b.root === "hdd") { gameList = gameList.concat(ScanGames(path, dev, "")); break; }

					const directory = os.readdir(path)[0];
					if (!directory) { return; }

					if (directory.includes("DVD")) 	{ gameList = gameList.concat(ScanGames(`${path}/DVD/`, dev, "dvd")); }
					if (directory.includes("CD")) 	{ gameList = gameList.concat(ScanGames(`${path}/CD/`, dev, "cd")); }
					if (directory.includes("PS2")) 	{
						const subdir = os.readdir(`${path}PS2/`)[0];
						if 	   (subdir.includes("DVD")) { gameList = gameList.concat(ScanGames(`${path}PS2/DVD/`, dev, "dvd")); }
						else if (subdir.includes("CD")) { gameList = gameList.concat(ScanGames(`${path}PS2/CD/`, dev, "cd")); }
					}
				}
			}

			if (gameList.length > 1) { gameList.sort((a, b) => a.Name.localeCompare(b.Name)); }

			return gameList;
    ]]>
  </Options>
  <Default>
    <![CDATA[
			let val = 0;
			const cfg = CfgMan.Get("neutrino.cfg");
			if ('last' in cfg) {
				const index = this.Items.findIndex(item => item.Name === cfg["last"]);
				val = (index > -1) ? index : 0;
			}
			return val;
		]]>
  </Default>
  <Context Name="OptionContext" Filter="Custom" Condition="item.GameID">
		<Component Name="{INFO}" Icon="-1">
      <Confirm>
        <![CDATA[
        function(index, item) {
					DashUISetDialog(item.Dialog);
				}
      ]]>
      </Confirm>
			<Dialog Icon="-1" Title="" BG="false" Type="INFO" BackBtn="true" >
				<Info>
					<Item Name="{TITLE}" Value="{DashUI.SubMenu.ItemCollection[DashUI.SubMenu.Level].Items[DashUI.SubMenu.Items.Current].Name}" Selectable="false" />
					<Item Name="{DEVICE}" Value="{DashUI.SubMenu.ItemCollection[DashUI.SubMenu.Level].Items[DashUI.SubMenu.Items.Current].Data.dev.toUpperCase()}" Selectable="false" />
          <Item Name="{SIZE}" Value="{DashUI.SubMenu.ItemCollection[DashUI.SubMenu.Level].Items[DashUI.SubMenu.Items.Current].Data.fsize}" Selectable="false" />
          <Item Name="{MEDIA}" Value="{DashUI.SubMenu.ItemCollection[DashUI.SubMenu.Level].Items[DashUI.SubMenu.Items.Current].Data.mt.toUpperCase()}" Selectable="false" />
				</Info>
			</Dialog>
    </Component>
    <Component Name="{CATEGORY.SETTINGS}" Icon="-1">
      <Confirm>
        <![CDATA[
        function(index, item) {
					const items = item.Dialog.Info;
					const config = CfgMan.Get(`${DashUI.SubMenu.ItemCollection[DashUI.SubMenu.Level].Items[DashUI.SubMenu.Items.Current].GameID.toUpperCase()}.cfg`);
          items[0].Selected = ('VMC0' in config) ? 1 : 0;
					items[1].Selected = ('VMC1' in config) ? 1 : 0;
					if ("gc" in config)	{
						const gc = config["gc"];
						items[2].Selected = /0/.test(gc) ? 1 : 0;
						items[3].Selected = /2/.test(gc) ? 1 : 0;
						items[4].Selected = /5/.test(gc) ? 1 : 0;
						items[5].Selected = /7/.test(gc) ? 1 : 0;
						items[6].Selected = /3/.test(gc) ? 1 : 0;
					}
					else { for (let i = 2; i < items.length; i++) { items[i].Selected = 0; } }

					DashUISetDialog(item.Dialog);
				}
      ]]>
      </Confirm>
      <Dialog Icon="-1" Title="" BG="false" Type="INFO" BackBtn="true" ConfirmBtn="true" >
        <Info>
          <Item Name="{VMC1}" Selectable="true">
            <Value>
              <Option value="{NO}" />
              <Option value="{YES}" />
            </Value>
          </Item>
          <Item Name="{VMC2}" Selectable="true">
            <Value>
              <Option value="{NO}" />
              <Option value="{YES}" />
            </Value>
          </Item>
          <Item Name="{GC_0}" Selectable="true">
            <Value>
              <Option value="{NO}" />
              <Option value="{YES}" />
            </Value>
          </Item>
          <Item Name="{GC_2}" Selectable="true">
            <Value>
              <Option value="{NO}" />
              <Option value="{YES}" />
            </Value>
          </Item>
          <Item Name="{GC_5}" Selectable="true">
            <Value>
              <Option value="{NO}" />
              <Option value="{YES}" />
            </Value>
          </Item>
          <Item Name="{GC_7}" Selectable="true">
            <Value>
              <Option value="{NO}" />
              <Option value="{YES}" />
            </Value>
          </Item>
          <Item Name="{GC_3}" Selectable="true">
            <Value>
              <Option value="{NO}" />
              <Option value="{YES}" />
            </Value>
          </Item>
        </Info>
        <Dialog Name="SaveSettingsDialog" Icon="-1" Title="" BG="false" Type="TEXT" Text="{WAIT}" Align="HCENTER">
          <Task>
            <![CDATA[
							function() {
								const gameID = DashUI.SubMenu.ItemCollection[DashUI.SubMenu.Level].Items[DashUI.SubMenu.Items.Current].GameID.toUpperCase();
								const config = CfgMan.Get(`${gameID}.cfg`);
								const vmcgroups = CfgMan.Get("PS2VMCGRP.cfg");
								let vmcgameid = gameID;
								if (gameID in vmcgroups) { vmcgameid = vmcgroups[gameID]; }

								const info = DashUI.Dialog.Data[DashUI.Dialog.Level - 1].Info;

								let gcModes = "";
								if (info[2].Selected === 1) { gcModes += "0"; }
								if (info[3].Selected === 1) { gcModes += "2"; }
								if (info[4].Selected === 1) { gcModes += "5"; }
								if (info[5].Selected === 1) { gcModes += "7"; }
								if (info[6].Selected === 1) { gcModes += "3"; }
								if (gcModes) { config["gc"] = gcModes; }
								else if ('gc' in config) { delete config.gc; }

								if (info[0].Selected === 1) { config["VMC0"] = vmcgameid; }
								else if ('VMC0' in config) { delete config.VMC0; }
								if (info[1].Selected === 1) { config["VMC1"] = vmcgameid; }
								else if ('VMC1' in config) { delete config.VMC1; }

								CfgMan.Push(`${gameID}.cfg`, config);

								let vmcCount = 1;
								const vmcs = [];

								for(let i = 0; i < 2; i++) {
									const vmcpath = `${PATHS.VMC}${vmcgameid}_${i.toString()}.vmc`;
									if ((info[i].Selected !== 1) || (std.exists(vmcpath))) { continue; }
                  vmcs.push(vmcpath);
								}

                const vmcLength = vmcs.length;

                if (vmcLength < 1) {
									UIAnimationDialogFade_Start(false);
									return;
								}

								DashUI.Dialog.Data[DashUI.Dialog.Level].Y = -60;
								let mcTxt = `${getLocalText(XMBLANG.COPY_VMC_MSG)} ${vmcCount}/${vmcLength}`;

								const src = `${PATHS.VMC}blank.vmc`;
								const BLOCK_SIZE = 64 * 1024;
								const buffer = new ArrayBuffer(BLOCK_SIZE);

                let fdSrc = os.open(src, os.O_RDONLY);
								let fdDst = os.open(vmcs.shift(), os.O_WRONLY | os.O_CREAT | os.O_TRUNC);

								if (fdSrc < 0 || fdDst < 0) {
									throw new Error("Error opening VMC source or destination file");
                }

								const totalSize = 8 * 1024 * 1024;
								let copied = 0;
                const PbarAFade = createFade();
                UICONST.LayersFg.push(() => {
                  if (DashUI.PbarAlpha < 1) { PbarAFade.Progress = 0.1f; DashUI.AnimationQueue.push(() => UIAnimationCommon_Work(PbarAFade, 0.2f)); }
									DashUI.PbarAlpha = ~~(128 * PbarAFade.Progress);
                  DrawProgressBar({X: 0, Y: 0}, ~~((copied / totalSize) * 100), mcTxt);
                });

								const CopIval = os.setInterval(() => {
										const toRead = Math.min(BLOCK_SIZE, totalSize - copied);
										if (toRead <= 0) {
                      if (vmcs.length > 0) {
												vmcCount++;
												mcTxt = `${getLocalText(XMBLANG.COPY_VMC_MSG)} ${vmcCount}/${vmcLength}`;
                        os.seek(fdSrc, 0, std.SEEK_SET);
												os.close(fdDst);
                        fdDst = os.open(vmcs.shift(), os.O_WRONLY | os.O_CREAT | os.O_TRUNC);
												copied = 0;
                      }
                      else {
												UICONST.LayersFg.pop();
												os.close(fdSrc);
												os.close(fdDst);
												os.clearInterval(CopIval);
												UIAnimationDialogFade_Start(false);
												return;
                      }
                    }

										const bytesRead = os.read(fdSrc, buffer, 0, toRead);
										let written = 0;
										while (written < bytesRead) {
											const bw = os.write(fdDst, buffer, written, bytesRead - written);
											if (bw < 0) throw new Error("Error writing VMC");
											written += bw;
										}

										copied += bytesRead;
                }, 0);
							}
						]]>
          </Task>
        </Dialog>
        <Event On="Confirm" Type="Transition" To="SaveSettingsDialog"/>
      </Dialog>
    </Component>
  </Context>
</App>
